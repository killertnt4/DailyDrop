<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DailyDrop - Professional TikTok Slide Editor</title>
    <meta name="description" content="Professional TikTok slide editor with server-hosted image gallery and TikTok-style text overlays">
    <meta name="keywords" content="TikTok, slide editor, video content, text overlay, DailyDrop">
    <meta name="author" content="DailyDrop">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iNiIgZmlsbD0iIzNiODJmNiIvPgo8cGF0aCBkPSJNOCA3SDE2VjI1SDhWN1oiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0xOCAxOEgyNFYxM0gxOFY3WiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTE4IDE5SDI0VjI1SDE4VjE5WiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==">
    
    <!-- External Resources -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- TikTok Sans Font -->
    <style>
        @font-face {
            font-family: 'TikTok Sans';
            src: url('https://fonts.gstatic.com/s/tiktoksans/v1/B5Y9YYeGqKwgKmJvOIRsTA.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'TikTok Sans';
            src: url('https://fonts.gstatic.com/s/tiktoksans/v1/B5Y_YYeGqKwgKmJvOIRsVInMjw.woff2') format('woff2');
            font-weight: 600;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'TikTok Sans';
            src: url('https://fonts.gstatic.com/s/tiktoksans/v1/B5Y9YYeGqKwgKmJvOIRsXA.woff2') format('woff2');
            font-weight: 700;
            font-style: normal;
            font-display: swap;
        }
    </style>
    
    <style>
        :root {
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --accent-primary: #3b82f6;
            --accent-secondary: #8b5cf6;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --border-color: #334155;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        * {
            font-family: 'Poppins', sans-serif;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            min-height: 100vh;
            color: var(--text-primary);
            margin: 0;
            padding: 0;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 3:4 Aspect Ratio Canvas Container */
        #canvas-container { 
            position: relative; 
            margin: 0 auto; 
            overflow: hidden; 
            width: 100%;
            max-width: 405px; /* 3:4 ratio: 405x540 */
            aspect-ratio: 3/4;
            background: #333;
            border-radius: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas { 
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block; 
            border-radius: 16px;
            border: none;
        }

        .control-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .control-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 12px;
            max-height: 400px;
            overflow-y: auto;
        }

        .gallery-image {
            position: relative;
            aspect-ratio: 3/4;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .gallery-image:hover {
            transform: scale(1.05);
            border-color: var(--accent-primary);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .gallery-image.selected {
            border-color: var(--success);
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.5);
        }

        .gallery-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .gallery-image .image-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            color: white;
            padding: 8px;
            font-size: 10px;
            text-align: center;
        }

        .slide-navigation {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .slide-nav-btn {
            padding: 8px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .slide-nav-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .slide-nav-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .error-banner {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--danger);
            color: #fca5a5;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 14px;
            display: none;
        }

        .success-banner {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid var(--success);
            color: #6ee7b7;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 14px;
            display: none;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-secondary);
            border-color: var(--accent-primary);
        }

        .btn-success {
            background: var(--success);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-success:hover:not(:disabled) {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
        }

        .input-field {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 12px;
            color: var(--text-primary);
            transition: all 0.3s ease;
            width: 100%;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .slider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-secondary);
            outline: none;
            transition: all 0.3s ease;
            width: 100%;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }

        .section-header {
            color: var(--text-primary);
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border-color);
        }

        .header-brand {
            display: flex;
            align-items: center;
            margin-bottom: 2rem;
        }

        .brand-text {
            font-size: 2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .preset-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preset-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }

            .brand-text {
                font-size: 1.5rem;
            }

            .control-card {
                padding: 16px;
            }

            #canvas-container {
                max-width: 100%;
            }

            .image-gallery {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 8px;
                padding: 12px;
            }
        }

        /* Error states */
        .error-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .retry-btn {
            margin-top: 16px;
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="spinner"></div>
    </div>

    <div class="max-w-7xl mx-auto p-4 md:p-6">
        <!-- Header -->
        <header class="header-brand">
            <div>
                <h1 class="brand-text">DailyDrop</h1>
                <p class="text-gray-400 text-sm font-medium">Professional TikTok Slide Editor</p>
            </div>
        </header>

        <!-- Error/Success Messages -->
        <div id="error-banner" class="error-banner"></div>
        <div id="success-banner" class="success-banner"></div>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Image Gallery Panel -->
            <section class="control-card order-1">
                <h2 class="section-header">📸 Select Images</h2>
                
                <!-- Slide Navigation -->
                <div id="slide-navigation" class="slide-navigation">
                    <div class="error-state" id="gallery-loading">
                        <div class="text-sm">Loading image gallery...</div>
                    </div>
                </div>
                
                <!-- Image Gallery -->
                <div id="image-gallery" class="image-gallery">
                    <div class="error-state">
                        <div class="text-sm">Select a slide to view images</div>
                    </div>
                </div>

                <!-- Canvas Background -->
                <div class="mt-6">
                    <label for="canvas-bg" class="block text-sm font-medium text-gray-300 mb-2">Canvas Background:</label>
                    <select id="canvas-bg" class="input-field">
                        <option value="#000000">Black</option>
                        <option value="#ffffff">White</option>
                        <option value="#f3f4f6">Light Gray</option>
                        <option value="#1f2937">Dark Gray</option>
                        <option value="#3b82f6">Blue</option>
                        <option value="#ef4444">Red</option>
                        <option value="#10b981">Green</option>
                        <option value="#f59e0b">Orange</option>
                    </select>
                </div>
                
                <div class="flex gap-3 mt-6">
                    <button id="export-current" class="btn-success flex-1" aria-label="Export current slide">
                        Export Current Image
                    </button>
                    <button id="export-slide" class="btn-primary flex-1" aria-label="Export entire slide">
                        Export Entire Slide
                    </button>
                </div>
            </section>

            <!-- Editor Panel -->
            <section class="control-card order-3 lg:order-2">
                <h2 class="section-header">🎨 Edit Image</h2>
                <div class="mb-4 p-4 bg-blue-900/30 rounded-lg border border-blue-500/30">
                    <div class="text-sm text-blue-200 font-medium" id="current-info">
                        Select an image from the gallery to start editing
                    </div>
                </div>

                <div id="canvas-container" class="mb-6" role="img" aria-label="Image editor canvas">
                    <canvas id="editor-canvas" width="1080" height="1440" aria-label="Slide editing area"></canvas>
                </div>
                
                <nav class="flex justify-between gap-4" aria-label="Image navigation">
                    <button id="prev-image" class="btn-primary flex-1" aria-label="Previous image">← Previous</button>
                    <button id="next-image" class="btn-primary flex-1" aria-label="Next image">Next →</button>
                </nav>
            </section>

            <!-- Text Controls Panel -->
            <section class="control-card order-2 lg:order-3">
                <h2 class="section-header">✍️ Add TikTok Text</h2>
                
                <!-- TikTok Style Presets -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-300 mb-2">TikTok Style Presets:</label>
                    <div class="flex gap-2 flex-wrap">
                        <button class="preset-btn" data-preset="classic">Classic (Black on White)</button>
                        <button class="preset-btn" data-preset="bold">Bold White</button>
                        <button class="preset-btn" data-preset="colorful">Colorful</button>
                    </div>
                </div>
                
                <div class="mb-4">
                    <label for="text-content" class="block text-sm font-medium text-gray-300 mb-2">Text Content:</label>
                    <textarea id="text-content" class="input-field" rows="4" placeholder="Enter your TikTok text...&#10;Use Enter for new lines"></textarea>
                </div>
                
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="font-size" class="block text-sm font-medium text-gray-300 mb-2">Font Size:</label>
                        <input type="range" id="font-size" min="20" max="120" value="60" class="slider">
                        <span id="font-size-value" class="text-sm text-gray-400">60px</span>
                    </div>
                    <div>
                        <label for="line-height" class="block text-sm font-medium text-gray-300 mb-2">Line Height:</label>
                        <input type="range" id="line-height" min="1.0" max="2.0" step="0.1" value="1.2" class="slider">
                        <span id="line-height-value" class="text-sm text-gray-400">1.2x</span>
                    </div>
                </div>
                
                <div class="mb-4">
                    <label for="vertical-position" class="block text-sm font-medium text-gray-300 mb-2">Vertical Position:</label>
                    <div class="flex gap-2 mb-2">
                        <button class="btn-secondary" data-position="top">Top</button>
                        <button class="btn-secondary" data-position="middle">Middle</button>
                        <button class="btn-secondary" data-position="bottom">Bottom</button>
                    </div>
                    <input type="range" id="vertical-position" min="100" max="1340" value="720" class="slider">
                    <span id="vertical-value" class="text-sm text-gray-400">720px</span>
                </div>
                
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="text-color" class="block text-sm font-medium text-gray-300 mb-2">Text Color:</label>
                        <input type="color" id="text-color" value="#000000" class="input-field h-12">
                    </div>
                    <div>
                        <label for="bg-color" class="block text-sm font-medium text-gray-300 mb-2">Background Color:</label>
                        <input type="color" id="bg-color" value="#ffffff" class="input-field h-12">
                    </div>
                </div>
                
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="font-family" class="block text-sm font-medium text-gray-300 mb-2">Font:</label>
                        <select id="font-family" class="input-field">
                            <option value="TikTok Sans" selected>TikTok Sans (Official)</option>
                            <option value="Montserrat">Montserrat</option>
                            <option value="Poppins">Poppins</option>
                            <option value="Arial">Arial</option>
                            <option value="Impact">Impact</option>
                        </select>
                    </div>
                    <div>
                        <label for="font-weight" class="block text-sm font-medium text-gray-300 mb-2">Weight:</label>
                        <select id="font-weight" class="input-field">
                            <option value="400">Normal</option>
                            <option value="600" selected>Semi Bold</option>
                            <option value="700">Bold</option>
                        </select>
                    </div>
                </div>
                
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="text-align" class="block text-sm font-medium text-gray-300 mb-2">Alignment:</label>
                        <select id="text-align" class="input-field">
                            <option value="left">Left</option>
                            <option value="center" selected>Center</option>
                            <option value="right">Right</option>
                        </select>
                    </div>
                    <div>
                        <label for="border-radius" class="block text-sm font-medium text-gray-300 mb-2">Corner Radius:</label>
                        <input type="range" id="border-radius" min="0" max="50" value="32" class="slider">
                        <span id="radius-value" class="text-sm text-gray-400">32px</span>
                    </div>
                </div>
                
                <div class="flex gap-3 mb-4">
                    <button id="add-text" class="btn-primary flex-1">Add Text</button>
                    <button id="preview-text" class="btn-secondary flex-1">Preview</button>
                </div>
                
                <div id="text-layers" class="space-y-2 max-h-48 overflow-y-auto">
                    <p class="text-gray-500 text-center py-4">No text layers added</p>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Enhanced error handling and logging
        class ErrorHandler {
            static log(error, context = '') {
                console.error(`[${context}] Error:`, error);
                this.showUserMessage(`Error: ${error.message || 'Something went wrong'}`, 'error');
            }

            static showUserMessage(message, type = 'info') {
                const banner = document.getElementById(type === 'error' ? 'error-banner' : 'success-banner');
                if (banner) {
                    banner.textContent = message;
                    banner.style.display = 'block';
                    setTimeout(() => {
                        banner.style.display = 'none';
                    }, 5000);
                }
            }

            static async retry(asyncFunction, maxAttempts = 3, delay = 1000) {
                for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                    try {
                        return await asyncFunction();
                    } catch (error) {
                        if (attempt === maxAttempts) {
                            throw error;
                        }
                        await new Promise(resolve => setTimeout(resolve, delay * attempt));
                    }
                }
            }
        }

        // Global error handlers
        window.addEventListener('error', (e) => {
            ErrorHandler.log(e.error, 'Global');
        });

        window.addEventListener('unhandledrejection', (e) => {
            ErrorHandler.log(new Error(e.reason), 'Promise');
        });

        // Application state
        const AppState = {
            images: new Map(), // slideNumber -> [image1, image2, ...]
            currentSlide: 1,
            currentImageIndex: 0,
            textLayers: [],
            isLoading: false,
            canvas: null,
            ctx: null,

            init() {
                try {
                    this.canvas = document.getElementById('editor-canvas');
                    this.ctx = this.canvas.getContext('2d');
                    if (!this.canvas || !this.ctx) {
                        throw new Error('Canvas initialization failed');
                    }
                } catch (error) {
                    ErrorHandler.log(error, 'AppState.init');
                    throw error;
                }
            },

            setCurrentImage(slideNumber, imageIndex) {
                try {
                    if (!this.images.has(slideNumber)) {
                        throw new Error(`Slide ${slideNumber} not found`);
                    }
                    const slideImages = this.images.get(slideNumber);
                    if (imageIndex >= slideImages.length || imageIndex < 0) {
                        throw new Error(`Image index ${imageIndex} out of range`);
                    }
                    this.currentSlide = slideNumber;
                    this.currentImageIndex = imageIndex;
                    this.textLayers = []; // Reset text layers when changing image
                } catch (error) {
                    ErrorHandler.log(error, 'AppState.setCurrentImage');
                }
            },

            getCurrentImage() {
                try {
                    const slideImages = this.images.get(this.currentSlide);
                    if (!slideImages || !slideImages[this.currentImageIndex]) {
                        return null;
                    }
                    return slideImages[this.currentImageIndex];
                } catch (error) {
                    ErrorHandler.log(error, 'AppState.getCurrentImage');
                    return null;
                }
            }
        };

        // Image loader with GitHub integration
        class ImageLoader {
            static BASE_PATH = './drive-download-20250729T142247Z-1-001';
            static SLIDE_COUNT = 10;
            static IMAGES_PER_SLIDE = 6;
            static SUPPORTED_FORMATS = ['.jpg', '.jpeg', '.png', '.webp'];

            static async loadSlideImages(slideNumber) {
                try {
                    const images = [];
                    const loadPromises = [];

                    for (let i = 1; i <= this.IMAGES_PER_SLIDE; i++) {
                        for (const format of this.SUPPORTED_FORMATS) {
                            const imagePath = `${this.BASE_PATH}/${slideNumber}/${i}${format}`;
                            
                            const promise = this.loadSingleImage(imagePath)
                                .then(img => {
                                    if (img) {
                                        images[i - 1] = {
                                            img,
                                            path: imagePath,
                                            slideNumber,
                                            imageNumber: i
                                        };
                                    }
                                })
                                .catch(() => {
                                    // Silently handle missing images with different formats
                                });
                            
                            loadPromises.push(promise);
                        }
                    }

                    await Promise.all(loadPromises);
                    return images.filter(Boolean); // Remove undefined entries
                } catch (error) {
                    ErrorHandler.log(error, `ImageLoader.loadSlideImages(${slideNumber})`);
                    return [];
                }
            }

            static loadSingleImage(path) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => resolve(null);
                    img.src = path;
                });
            }

            static async loadAllImages() {
                try {
                    AppState.isLoading = true;
                    this.updateLoadingState('Loading image gallery...');

                    const loadPromises = [];
                    for (let slide = 1; slide <= this.SLIDE_COUNT; slide++) {
                        loadPromises.push(
                            this.loadSlideImages(slide).then(images => {
                                if (images.length > 0) {
                                    AppState.images.set(slide, images);
                                }
                            })
                        );
                    }

                    await Promise.all(loadPromises);
                    
                    if (AppState.images.size === 0) {
                        throw new Error('No images could be loaded. Please check the image paths.');
                    }

                    ErrorHandler.showUserMessage(`Loaded ${AppState.images.size} slides successfully!`, 'success');
                    return true;
                } catch (error) {
                    ErrorHandler.log(error, 'ImageLoader.loadAllImages');
                    return false;
                } finally {
                    AppState.isLoading = false;
                    this.updateLoadingState('');
                }
            }

            static updateLoadingState(message) {
                const loadingDiv = document.getElementById('gallery-loading');
                if (loadingDiv) {
                    if (message) {
                        loadingDiv.innerHTML = `<div class="text-sm">${message}</div>`;
                        loadingDiv.style.display = 'block';
                    } else {
                        loadingDiv.style.display = 'none';
                    }
                }
            }
        }

        // Canvas renderer with 3:4 aspect ratio enforcement and proper TikTok text wrapping
        class CanvasRenderer {
            static CANVAS_WIDTH = 1080;
            static CANVAS_HEIGHT = 1440; // 3:4 ratio

            static cropImageTo3x4(img) {
                try {
                    const targetRatio = 3 / 4;
                    const imgRatio = img.width / img.height;
                    
                    let sourceX = 0, sourceY = 0, sourceWidth = img.width, sourceHeight = img.height;
                    
                    if (imgRatio > targetRatio) {
                        // Image is wider, crop width
                        sourceWidth = img.height * targetRatio;
                        sourceX = (img.width - sourceWidth) / 2;
                    } else if (imgRatio < targetRatio) {
                        // Image is taller, crop height
                        sourceHeight = img.width / targetRatio;
                        sourceY = (img.height - sourceHeight) / 2;
                    }
                    
                    return { sourceX, sourceY, sourceWidth, sourceHeight };
                } catch (error) {
                    ErrorHandler.log(error, 'CanvasRenderer.cropImageTo3x4');
                    return { sourceX: 0, sourceY: 0, sourceWidth: img.width, sourceHeight: img.height };
                }
            }

            static drawImage(imageData) {
                try {
                    if (!imageData || !AppState.ctx) return;

                    const { img } = imageData;
                    AppState.canvas.width = this.CANVAS_WIDTH;
                    AppState.canvas.height = this.CANVAS_HEIGHT;

                    // Clear canvas
                    AppState.ctx.fillStyle = document.getElementById('canvas-bg').value;
                    AppState.ctx.fillRect(0, 0, AppState.canvas.width, AppState.canvas.height);

                    // Crop and draw image to 3:4 ratio
                    const cropData = this.cropImageTo3x4(img);
                    AppState.ctx.drawImage(
                        img,
                        cropData.sourceX, cropData.sourceY, cropData.sourceWidth, cropData.sourceHeight,
                        0, 0, this.CANVAS_WIDTH, this.CANVAS_HEIGHT
                    );

                } catch (error) {
                    ErrorHandler.log(error, 'CanvasRenderer.drawImage');
                }
            }

            // Improved TikTok text rendering with proper line-by-line background wrapping
            static drawTikTokText(textConfig) {
                try {
                    if (!textConfig.text || !AppState.ctx) return;

                    const ctx = AppState.ctx;
                    const {
                        text, x, y, fontSize, fontFamily, fontWeight,
                        textColor, backgroundColor, borderRadius, align, lineHeight
                    } = textConfig;

                    // Set font
                    ctx.font = `${fontWeight} ${fontSize}px "${fontFamily}", sans-serif`;
                    ctx.textAlign = align;

                    const lines = text.split('\n').filter(line => line.trim() !== '');
                    const actualLineHeight = fontSize * lineHeight;
                    const padding = Math.max(16, fontSize * 0.4); // Dynamic padding based on font size

                    // Calculate starting Y position for multi-line text
                    const totalHeight = lines.length * actualLineHeight;
                    let startY = y - totalHeight / 2 + actualLineHeight / 2;

                    // Draw each line with its own background pill (TikTok style)
                    lines.forEach((line, index) => {
                        if (line.trim() === '') return;

                        const lineY = startY + (index * actualLineHeight);
                        
                        // Measure text width for this specific line
                        const metrics = ctx.measureText(line);
                        const lineWidth = metrics.width;
                        
                        // Calculate background dimensions for this line
                        const bgWidth = lineWidth + (padding * 2);
                        const bgHeight = actualLineHeight * 0.9; // Slightly smaller than line height
                        
                        // Calculate X position based on alignment
                        let lineX = x;
                        let bgX = x - bgWidth / 2;
                        
                        if (align === 'left') {
                            lineX = x + padding;
                            bgX = x;
                        } else if (align === 'right') {
                            lineX = x - padding;
                            bgX = x - bgWidth;
                        }

                        const bgY = lineY - actualLineHeight / 2;

                        // Draw background pill for this line only
                        ctx.fillStyle = backgroundColor;
                        this.roundRect(ctx, bgX, bgY, bgWidth, bgHeight, borderRadius);
                        ctx.fill();

                        // Draw text for this line
                        ctx.fillStyle = textColor;
                        ctx.fillText(line, lineX, lineY);
                    });

                } catch (error) {
                    ErrorHandler.log(error, 'CanvasRenderer.drawTikTokText');
                }
            }

            static roundRect(ctx, x, y, width, height, radius) {
                try {
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x + width - radius, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                    ctx.lineTo(x + width, y + height - radius);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    ctx.lineTo(x + radius, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                    ctx.lineTo(x, y + radius);
                    ctx.quadraticCurveTo(x, y, x + radius, y);
                    ctx.closePath();
                } catch (error) {
                    ErrorHandler.log(error, 'CanvasRenderer.roundRect');
                }
            }

            static renderCurrentImage() {
                try {
                    const currentImage = AppState.getCurrentImage();
                    if (!currentImage) {
                        // Show placeholder
                        AppState.ctx.fillStyle = document.getElementById('canvas-bg').value;
                        AppState.ctx.fillRect(0, 0, AppState.canvas.width, AppState.canvas.height);
                        AppState.ctx.fillStyle = '#666';
                        AppState.ctx.font = '24px Poppins';
                        AppState.ctx.textAlign = 'center';
                        AppState.ctx.fillText('Select an image to edit', AppState.canvas.width / 2, AppState.canvas.height / 2);
                        return;
                    }

                    this.drawImage(currentImage);

                    // Draw text layers
                    AppState.textLayers.forEach(textLayer => {
                        this.drawTikTokText(textLayer);
                    });

                    UI.updateCurrentInfo();
                } catch (error) {
                    ErrorHandler.log(error, 'CanvasRenderer.renderCurrentImage');
                }
            }
        }

        // UI Controller
        class UI {
            static renderSlideNavigation() {
                try {
                    const nav = document.getElementById('slide-navigation');
                    if (!nav) return;

                    nav.innerHTML = '';
                    
                    if (AppState.images.size === 0) {
                        nav.innerHTML = '<div class="error-state"><div class="text-sm">No slides available</div></div>';
                        return;
                    }

                    Array.from(AppState.images.keys()).sort((a, b) => a - b).forEach(slideNumber => {
                        const btn = document.createElement('button');
                        btn.className = `slide-nav-btn ${slideNumber === AppState.currentSlide ? 'active' : ''}`;
                        btn.textContent = `Slide ${slideNumber}`;
                        btn.onclick = () => this.selectSlide(slideNumber);
                        nav.appendChild(btn);
                    });
                } catch (error) {
                    ErrorHandler.log(error, 'UI.renderSlideNavigation');
                }
            }

            static renderImageGallery() {
                try {
                    const gallery = document.getElementById('image-gallery');
                    if (!gallery) return;

                    const slideImages = AppState.images.get(AppState.currentSlide);
                    if (!slideImages || slideImages.length === 0) {
                        gallery.innerHTML = '<div class="error-state"><div class="text-sm">No images in this slide</div></div>';
                        return;
                    }

                    gallery.innerHTML = '';
                    slideImages.forEach((imageData, index) => {
                        const imgDiv = document.createElement('div');
                        imgDiv.className = `gallery-image ${index === AppState.currentImageIndex ? 'selected' : ''}`;
                        
                        const img = document.createElement('img');
                        img.src = imageData.img.src;
                        img.alt = `Image ${index + 1}`;
                        img.onerror = () => {
                            img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzMzMyIvPjx0ZXh0IHg9IjUwIiB5PSI1MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjNjY2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+RXJyb3I8L3RleHQ+PC9zdmc+';
                        };

                        const info = document.createElement('div');
                        info.className = 'image-info';
                        info.textContent = `${index + 1}`;

                        imgDiv.appendChild(img);
                        imgDiv.appendChild(info);
                        imgDiv.onclick = () => this.selectImage(AppState.currentSlide, index);
                        
                        gallery.appendChild(imgDiv);
                    });
                } catch (error) {
                    ErrorHandler.log(error, 'UI.renderImageGallery');
                }
            }

            static selectSlide(slideNumber) {
                try {
                    AppState.currentSlide = slideNumber;
                    AppState.currentImageIndex = 0;
                    AppState.textLayers = [];
                    this.renderSlideNavigation();
                    this.renderImageGallery();
                    CanvasRenderer.renderCurrentImage();
                } catch (error) {
                    ErrorHandler.log(error, 'UI.selectSlide');
                }
            }

            static selectImage(slideNumber, imageIndex) {
                try {
                    AppState.setCurrentImage(slideNumber, imageIndex);
                    this.renderImageGallery();
                    CanvasRenderer.renderCurrentImage();
                } catch (error) {
                    ErrorHandler.log(error, 'UI.selectImage');
                }
            }

            static updateCurrentInfo() {
                try {
                    const info = document.getElementById('current-info');
                    if (!info) return;

                    const currentImage = AppState.getCurrentImage();
                    if (!currentImage) {
                        info.textContent = 'No image selected';
                        return;
                    }

                    info.innerHTML = `
                        <strong>Slide ${AppState.currentSlide}</strong> • 
                        Image ${AppState.currentImageIndex + 1} • 
                        Size: ${currentImage.img.width}x${currentImage.img.height}
                    `;
                } catch (error) {
                    ErrorHandler.log(error, 'UI.updateCurrentInfo');
                }
            }

            static renderTextLayers() {
                try {
                    const container = document.getElementById('text-layers');
                    if (!container) return;

                    if (AppState.textLayers.length === 0) {
                        container.innerHTML = '<p class="text-gray-500 text-center py-4">No text layers added</p>';
                        return;
                    }

                    container.innerHTML = '';
                    AppState.textLayers.forEach((layer, index) => {
                        const div = document.createElement('div');
                        div.className = 'bg-gray-700 p-3 rounded-lg flex justify-between items-center';
                        
                        const preview = layer.text.length > 20 ? layer.text.substring(0, 20) + '...' : layer.text;
                        div.innerHTML = `
                            <span class="text-sm">${preview}</span>
                            <button class="btn-secondary text-red-400" onclick="TextController.removeLayer(${index})">Remove</button>
                        `;
                        
                        container.appendChild(div);
                    });
                } catch (error) {
                    ErrorHandler.log(error, 'UI.renderTextLayers');
                }
            }
        }

        // Text controller with TikTok presets
        class TextController {
            static presets = {
                classic: {
                    fontFamily: 'TikTok Sans',
                    fontWeight: '600',
                    fontSize: 60,
                    textColor: '#000000',
                    backgroundColor: '#ffffff',
                    borderRadius: 32,
                    lineHeight: 1.2
                },
                bold: {
                    fontFamily: 'TikTok Sans',
                    fontWeight: '700',
                    fontSize: 70,
                    textColor: '#ffffff',
                    backgroundColor: '#000000',
                    borderRadius: 0,
                    lineHeight: 1.1
                },
                colorful: {
                    fontFamily: 'TikTok Sans',
                    fontWeight: '600',
                    fontSize: 55,
                    textColor: '#ffffff',
                    backgroundColor: '#ff6b6b',
                    borderRadius: 25,
                    lineHeight: 1.3
                }
            };

            static applyPreset(presetName) {
                try {
                    const preset = this.presets[presetName];
                    if (!preset) return;

                    document.getElementById('font-family').value = preset.fontFamily;
                    document.getElementById('font-weight').value = preset.fontWeight;
                    document.getElementById('font-size').value = preset.fontSize;
                    document.getElementById('text-color').value = preset.textColor;
                    document.getElementById('bg-color').value = preset.backgroundColor;
                    document.getElementById('border-radius').value = preset.borderRadius;
                    document.getElementById('line-height').value = preset.lineHeight;

                    this.updateSliderValues();
                    ErrorHandler.showUserMessage(`Applied ${presetName} preset`, 'success');
                } catch (error) {
                    ErrorHandler.log(error, 'TextController.applyPreset');
                }
            }

            static addTextLayer() {
                try {
                    const text = document.getElementById('text-content').value.trim();
                    if (!text) {
                        ErrorHandler.showUserMessage('Please enter some text', 'error');
                        return;
                    }

                    const textConfig = {
                        text,
                        x: this.getXPosition(),
                        y: parseInt(document.getElementById('vertical-position').value),
                        fontSize: parseInt(document.getElementById('font-size').value),
                        fontFamily: document.getElementById('font-family').value,
                        fontWeight: document.getElementById('font-weight').value,
                        textColor: document.getElementById('text-color').value,
                        backgroundColor: document.getElementById('bg-color').value,
                        borderRadius: parseInt(document.getElementById('border-radius').value),
                        align: document.getElementById('text-align').value,
                        lineHeight: parseFloat(document.getElementById('line-height').value),
                        id: Date.now()
                    };

                    AppState.textLayers.push(textConfig);
                    CanvasRenderer.renderCurrentImage();
                    UI.renderTextLayers();
                    
                    // Clear text input
                    document.getElementById('text-content').value = '';
                    ErrorHandler.showUserMessage('Text layer added successfully', 'success');
                } catch (error) {
                    ErrorHandler.log(error, 'TextController.addTextLayer');
                }
            }

            static getXPosition() {
                const align = document.getElementById('text-align').value;
                switch (align) {
                    case 'left': return 100;
                    case 'right': return CanvasRenderer.CANVAS_WIDTH - 100;
                    default: return CanvasRenderer.CANVAS_WIDTH / 2;
                }
            }

            static removeLayer(index) {
                try {
                    if (index >= 0 && index < AppState.textLayers.length) {
                        AppState.textLayers.splice(index, 1);
                        CanvasRenderer.renderCurrentImage();
                        UI.renderTextLayers();
                        ErrorHandler.showUserMessage('Text layer removed', 'success');
                    }
                } catch (error) {
                    ErrorHandler.log(error, 'TextController.removeLayer');
                }
            }

            static updateSliderValues() {
                try {
                    document.getElementById('font-size-value').textContent = 
                        document.getElementById('font-size').value + 'px';
                    document.getElementById('line-height-value').textContent = 
                        document.getElementById('line-height').value + 'x';
                    document.getElementById('vertical-value').textContent = 
                        document.getElementById('vertical-position').value + 'px';
                    document.getElementById('radius-value').textContent = 
                        document.getElementById('border-radius').value + 'px';
                } catch (error) {
                    ErrorHandler.log(error, 'TextController.updateSliderValues');
                }
            }

            static setupEventListeners() {
                try {
                    // Preset buttons
                    document.querySelectorAll('[data-preset]').forEach(btn => {
                        btn.addEventListener('click', () => {
                            this.applyPreset(btn.dataset.preset);
                        });
                    });

                    // Position preset buttons
                    document.querySelectorAll('[data-position]').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const position = btn.dataset.position;
                            let value;
                            switch (position) {
                                case 'top': value = 300; break;
                                case 'middle': value = 720; break;
                                case 'bottom': value = 1140; break;
                            }
                            document.getElementById('vertical-position').value = value;
                            this.updateSliderValues();
                        });
                    });

                    // Slider updates
                    ['font-size', 'line-height', 'vertical-position', 'border-radius'].forEach(id => {
                        document.getElementById(id).addEventListener('input', this.updateSliderValues);
                    });

                    // Add text button
                    document.getElementById('add-text').addEventListener('click', () => {
                        this.addTextLayer();
                    });

                    // Preview button
                    document.getElementById('preview-text').addEventListener('click', () => {
                        CanvasRenderer.renderCurrentImage();
                    });

                } catch (error) {
                    ErrorHandler.log(error, 'TextController.setupEventListeners');
                }
            }
        }

        // Enhanced export functionality with bulk slide export
        class ExportController {
            static async exportCurrentImage() {
                try {
                    const currentImage = AppState.getCurrentImage();
                    if (!currentImage) {
                        ErrorHandler.showUserMessage('No image selected to export', 'error');
                        return;
                    }

                    const btn = document.getElementById('export-current');
                    const originalText = btn.textContent;
                    btn.textContent = 'Exporting...';
                    btn.disabled = true;

                    // Render current state
                    CanvasRenderer.renderCurrentImage();

                    // Create download
                    const dataUrl = AppState.canvas.toDataURL('image/jpeg', 0.95);
                    const link = document.createElement('a');
                    link.download = `slide_${AppState.currentSlide}_image_${AppState.currentImageIndex + 1}.jpg`;
                    link.href = dataUrl;
                    link.click();

                    ErrorHandler.showUserMessage('Image exported successfully!', 'success');
                } catch (error) {
                    ErrorHandler.log(error, 'ExportController.exportCurrentImage');
                } finally {
                    const btn = document.getElementById('export-current');
                    btn.textContent = 'Export Current Image';
                    btn.disabled = false;
                }
            }

            static async exportEntireSlide() {
                try {
                    const slideImages = AppState.images.get(AppState.currentSlide);
                    if (!slideImages || slideImages.length === 0) {
                        ErrorHandler.showUserMessage('No images in current slide to export', 'error');
                        return;
                    }

                    const btn = document.getElementById('export-slide');
                    const originalText = btn.textContent;
                    btn.textContent = 'Exporting Slide...';
                    btn.disabled = true;

                    // Create ZIP file
                    const zip = new JSZip();
                    const slideFolder = zip.folder(`slide_${AppState.currentSlide}`);

                    // Store current state
                    const originalImageIndex = AppState.currentImageIndex;
                    const originalTextLayers = [...AppState.textLayers];

                    for (let i = 0; i < slideImages.length; i++) {
                        // Set image and clear text layers for each image
                        AppState.currentImageIndex = i;
                        AppState.textLayers = [];
                        
                        // Render the image
                        CanvasRenderer.renderCurrentImage();

                        // Get canvas data
                        const dataUrl = AppState.canvas.toDataURL('image/jpeg', 0.95);
                        const base64Data = dataUrl.split(',')[1];
                        
                        // Add to ZIP
                        slideFolder.file(`image_${i + 1}.jpg`, base64Data, { base64: true });
                    }

                    // Restore original state
                    AppState.currentImageIndex = originalImageIndex;
                    AppState.textLayers = originalTextLayers;
                    CanvasRenderer.renderCurrentImage();

                    // Generate and download ZIP
                    const zipBlob = await zip.generateAsync({ type: 'blob' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(zipBlob);
                    link.download = `slide_${AppState.currentSlide}_complete.zip`;
                    link.click();

                    // Clean up
                    URL.revokeObjectURL(link.href);
                    
                    ErrorHandler.showUserMessage(`Slide ${AppState.currentSlide} exported successfully with ${slideImages.length} images!`, 'success');
                } catch (error) {
                    ErrorHandler.log(error, 'ExportController.exportEntireSlide');
                } finally {
                    const btn = document.getElementById('export-slide');
                    btn.textContent = 'Export Entire Slide';
                    btn.disabled = false;
                }
            }
        }

        // Navigation controller
        class NavigationController {
            static navigatePrevious() {
                try {
                    const slideImages = AppState.images.get(AppState.currentSlide);
                    if (!slideImages) return;

                    if (AppState.currentImageIndex > 0) {
                        AppState.currentImageIndex--;
                    } else {
                        // Go to previous slide
                        const slides = Array.from(AppState.images.keys()).sort((a, b) => a - b);
                        const currentIndex = slides.indexOf(AppState.currentSlide);
                        if (currentIndex > 0) {
                            const prevSlide = slides[currentIndex - 1];
                            const prevSlideImages = AppState.images.get(prevSlide);
                            AppState.currentSlide = prevSlide;
                            AppState.currentImageIndex = prevSlideImages.length - 1;
                        }
                    }

                    AppState.textLayers = [];
                    UI.renderSlideNavigation();
                    UI.renderImageGallery();
                    CanvasRenderer.renderCurrentImage();
                } catch (error) {
                    ErrorHandler.log(error, 'NavigationController.navigatePrevious');
                }
            }

            static navigateNext() {
                try {
                    const slideImages = AppState.images.get(AppState.currentSlide);
                    if (!slideImages) return;

                    if (AppState.currentImageIndex < slideImages.length - 1) {
                        AppState.currentImageIndex++;
                    } else {
                        // Go to next slide
                        const slides = Array.from(AppState.images.keys()).sort((a, b) => a - b);
                        const currentIndex = slides.indexOf(AppState.currentSlide);
                        if (currentIndex < slides.length - 1) {
                            const nextSlide = slides[currentIndex + 1];
                            AppState.currentSlide = nextSlide;
                            AppState.currentImageIndex = 0;
                        }
                    }

                    AppState.textLayers = [];
                    UI.renderSlideNavigation();
                    UI.renderImageGallery();
                    CanvasRenderer.renderCurrentImage();
                } catch (error) {
                    ErrorHandler.log(error, 'NavigationController.navigateNext');
                }
            }

            static setupEventListeners() {
                try {
                    document.getElementById('prev-image').addEventListener('click', this.navigatePrevious);
                    document.getElementById('next-image').addEventListener('click', this.navigateNext);

                    // Keyboard navigation
                    document.addEventListener('keydown', (e) => {
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                        
                        if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            this.navigatePrevious();
                        } else if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            this.navigateNext();
                        }
                    });
                } catch (error) {
                    ErrorHandler.log(error, 'NavigationController.setupEventListeners');
                }
            }
        }

        // Make TextController available globally
        window.TextController = TextController;

        // Main application initialization
        async function initializeApp() {
            try {
                // Initialize app state
                AppState.init();

                // Setup event listeners
                TextController.setupEventListeners();
                NavigationController.setupEventListeners();

                // Canvas background change handler
                document.getElementById('canvas-bg').addEventListener('change', () => {
                    CanvasRenderer.renderCurrentImage();
                });

                // Export handlers
                document.getElementById('export-current').addEventListener('click', () => {
                    ExportController.exportCurrentImage();
                });

                document.getElementById('export-slide').addEventListener('click', () => {
                    ExportController.exportEntireSlide();
                });

                // Load all images
                const success = await ImageLoader.loadAllImages();
                if (success && AppState.images.size > 0) {
                    // Select first slide and first image
                    const firstSlide = Math.min(...AppState.images.keys());
                    AppState.currentSlide = firstSlide;
                    AppState.currentImageIndex = 0;

                    // Render UI
                    UI.renderSlideNavigation();
                    UI.renderImageGallery();
                    CanvasRenderer.renderCurrentImage();
                    TextController.updateSliderValues();
                } else {
                    throw new Error('Failed to load images');
                }

            } catch (error) {
                ErrorHandler.log(error, 'App Initialization');
                // Show fallback UI
                document.getElementById('image-gallery').innerHTML = `
                    <div class="error-state">
                        <div class="text-sm mb-4">Failed to load image gallery</div>
                        <button class="retry-btn" onclick="location.reload()">Retry</button>
                    </div>
                `;
            } finally {
                // Hide loading screen
                setTimeout(() => {
                    const loadingScreen = document.getElementById('loading-screen');
                    loadingScreen.classList.add('hidden');
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500);
                }, 1000);
            }
        }

        // Start the application
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>
</html>
